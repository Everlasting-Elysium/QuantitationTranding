qlib_init:
    provider_uri: "/document/Code/QuantitationTranding/data/cn_data"
    region: cn
market: &market csi300
benchmark: &benchmark SH000300
data_handler_config: &data_handler_config
    start_time: 2008-01-01
    end_time: 2020-08-01
    fit_start_time: 2008-01-01
    fit_end_time: 2014-12-31
    instruments: *market
port_analysis_config: &port_analysis_config
    strategy:
        class: TopkDropoutStrategy
        module_path: qlib.contrib.strategy
        kwargs:
            signal: <PRED>
            topk: 50
            n_drop: 5
    backtest:
        start_time: 2017-01-01
        end_time: 2020-08-01
        account: 100000000
        benchmark: *benchmark
        exchange_kwargs:
            limit_threshold: 0.095
            deal_price: close
            open_cost: 0.0005
            close_cost: 0.0015
            min_cost: 5
task:
    model:
        class: LGBModel
        module_path: qlib.contrib.model.gbdt
        kwargs:
            loss: mse
            colsample_bytree: 0.8879
            learning_rate: 0.2
            subsample: 0.8789
            lambda_l1: 205.6999
            lambda_l2: 580.9768
            max_depth: 8
            num_leaves: 210
            num_threads: 20
    dataset:
        class: DatasetH
        module_path: qlib.data.dataset
        kwargs:
            handler:
                class: Alpha158
                module_path: qlib.contrib.data.handler
                kwargs: *data_handler_config
            segments:
                train: [2008-01-01, 2014-12-31]
                valid: [2015-01-01, 2016-12-31]
                test: [2017-01-01, 2020-08-01]
    record: 
        - class: SignalRecord
          module_path: qlib.workflow.record_temp
          kwargs: 
            model: <MODEL>
            dataset: <DATASET>
        - class: SigAnaRecord
          module_path: qlib.workflow.record_temp
          kwargs: 
            ana_long_short: False
            ann_scaler: 252
        - class: PortAnaRecord
          module_path: qlib.workflow.record_temp
          kwargs: 
            config: *port_analysis_config


   appArmorNodeTypeList := []string{
					"a40-vgpu-node",
					"a40-shared-5-node",
					"a40-shared-6-node",
					"a100-15c-shared-5-node",
					"a40-shared-7-node",
					"a40-shared-8-node",
					"a40-shared-9-node",
					"a40-shared-10-node"}

package main

import (
	"encoding/json"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	"fmt"

	"github.com/labstack/gommon/log"
)

// 测试：比较两个地址对同一路径和方法的响应。
// 使用环境变量配置：
//
//	URL1 - 第一个基地址（必须）
//	URL2 - 第二个基地址（必须）
//	REQUEST_PATH - 请求路径，默认为 "/"
//	METHOD - HTTP 方法，默认为 GET
//	TOKEN - Authorization 使用的 token（会自动加上 "Bearer " 前缀，除非已包含）
func main() {
	method := "GET"
	path := "/gputypes"
	url1 := "http://10.60.68.205:8080"
	token1 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjMzNzQ4NjUsImp0aSI6ImxhaS53ZWkxIiwiaXNzIjoiTlRTIn0.5MguzyRnJaX3SNkR_DCWt06FEY8zbimABR7GWAnjkso"
	url2 := "https://nts-gateway-kscnx.nioint.com"
	token2 := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjMzNzQyMjcsImp0aSI6ImxhaS53ZWkxIiwiaXNzIjoiTlRTIn0.V4zxXXwqu81OrzbA8b0waRk18enb8mDm7aoalGtpdtg"

	build := func(base, p string) string {
		base = strings.TrimRight(base, "/")
		p = strings.TrimLeft(p, "/")
		return base + "/" + p
	}

	full1 := build(url1, path)
	full2 := build(url2, path)

	log.Infof("Request: %s %s", method, path)
	log.Infof("URL1: %s", full1)
	log.Infof("URL2: %s", full2)

	s1, body1, err1 := doRequest(method, full1, token1)
	if err1 != nil {
		log.Errorf("URL1 error: %v", err1)
	} else {
		log.Infof("URL1 status: %d", s1)
		log.Info("URL1 Response JSON:")
		fmt.Println(normalizePossiblyEscapedJSON(body1))
	}

	s2, body2, err2 := doRequest(method, full2, token2)
	if err2 != nil {
		log.Errorf("URL2 error: %v", err2)
	} else {
		log.Infof("URL2 status: %d", s2)
		log.Info("URL2 Response JSON:")
		fmt.Println(normalizePossiblyEscapedJSON(body2))
	}

	if err1 == nil && err2 == nil {
		if body1 == body2 {
			log.Error("Responses are identical (after pretty-print).")
		} else {
			log.Infof("Responses differ (after pretty-print).")
		}
	}
}

func prettyJSON(b []byte) (string, error) {
	var v interface{}
	if err := json.Unmarshal(b, &v); err != nil {
		// not valid json, return raw
		return string(b), err
	}
	// If the top-level JSON is a string that itself contains JSON (escaped),
	// try to unmarshal the inner string and pretty print it. Otherwise
	// pretty-print the already-unmarshaled value.
	switch vv := v.(type) {
	case string:
		// try to parse inner JSON
		var inner interface{}
		if err := json.Unmarshal([]byte(vv), &inner); err == nil {
			if out, err := json.MarshalIndent(inner, "", "  "); err == nil {
				return string(out), nil
			}
		}
		// inner is not JSON, return raw unquoted string
		return vv, nil
	default:
		out, err := json.MarshalIndent(v, "", "  ")
		if err != nil {
			return string(b), err
		}
		return string(out), nil
	}
}

func doRequest(method, fullURL, token string) (int, string, error) {
	client := &http.Client{Timeout: 15 * time.Second}
	req, err := http.NewRequest(method, fullURL, nil)
	if err != nil {
		return 0, "", err
	}
	if token != "" {
		// accept both raw token or Bearer/... prefix
		low := strings.ToLower(token)
		if strings.HasPrefix(low, "bearer ") || strings.HasPrefix(low, "token ") {
			req.Header.Set("Authorization", token)
		} else {
			req.Header.Set("Authorization", "Bearer "+token)
		}
	}
	req.Header.Set("Accept", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return 0, "", err
	}
	defer resp.Body.Close()
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		return resp.StatusCode, "", err
	}
	pretty, _ := prettyJSON(b)
	// if pretty still contains escaped sequences like \n or \" (i.e. double-escaped),
	// try to unquote it so console output shows real newlines and quotes instead of
	// literal backslashes.
	if strings.Contains(pretty, `\\n`) || strings.Contains(pretty, `\\"`) || strings.Contains(pretty, `\\t`) {
		// attempt to unquote the whole string
		if unq, err := strconv.Unquote(`"` + pretty + `"`); err == nil {
			pretty = unq
		} else {
			// fallback: simple replacements for common escapes
			pretty = strings.ReplaceAll(pretty, `\\n`, "\n")
			pretty = strings.ReplaceAll(pretty, `\\t`, "\t")
			pretty = strings.ReplaceAll(pretty, `\\\"`, `\"`)
			pretty = strings.ReplaceAll(pretty, `\\"`, `"`)
		}
	}
	return resp.StatusCode, pretty, nil
}

// normalizePossiblyEscapedJSON 尝试把可能被多重转义的字符串恢复为可读的 JSON 字符串：
// - 循环尝试 strconv.Unquote
// - 使用常见替换把 "\\n" 之类替换成真实换行
// - 如果最终得到以 '{' 或 '[' 开头的合法 JSON，则美化并返回
// - 否则返回尽可能解码后的文本
func normalizePossiblyEscapedJSON(s string) string {
	t := s
	// limit attempts to avoid infinite loop
	for i := 0; i < 6; i++ {
		trimmed := strings.TrimSpace(t)
		// if it looks like JSON object/array, try to unmarshal and pretty-print
		if strings.HasPrefix(trimmed, "{") || strings.HasPrefix(trimmed, "[") {
			var v interface{}
			if err := json.Unmarshal([]byte(trimmed), &v); err == nil {
				if out, err := json.MarshalIndent(v, "", "  "); err == nil {
					return string(out)
				}
			}
		}

		// try unquote the whole string (handles leading/trailing quotes and escapes)
		if unq, err := strconv.Unquote(t); err == nil {
			t = unq
			continue
		}

		// replace common double-escape sequences
		prev := t
		t = strings.ReplaceAll(t, `\\n`, "\n")
		t = strings.ReplaceAll(t, `\\t`, "\t")
		t = strings.ReplaceAll(t, `\\r`, "\r")
		t = strings.ReplaceAll(t, `\\\"`, `\"`)
		t = strings.ReplaceAll(t, `\\"`, `"`)
		if t == prev {
			break
		}
	}
	return t
}


